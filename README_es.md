<h1 align="center">
  <img alt="SML logo" src="https://github.com/alexminator/SML/blob/master/img/SML.png" width="300px"/><br/>
  ${\color{#ff0000}S}{\color{#ff6e00}m}{\color{#ffdd00}a}{\color{#b2ff00}r}{\color{#48ff00}t}\ {\color{#00ff26}M}{\color{#00ff95}u}{\color{#00fbff}s}{\color{#0091ff}i}{\color{#0022ff}c}\ {\color{#4d00ff}L}{\color{#b700ff}a}{\color{#ff00d9}m}{\color{#ff006a}p} $
</h1>
<h4 align="center">
  <a href="https://github.com/alexminator/SML/blob/master/README_es.md">
    <img height="20px" src="https://img.shields.io/badge/ES-flag.svg?color=555555&style=flat-square&logo=data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3NTAgNTAwIj4NCjxwYXRoIGZpbGw9IiNjNjBiMWUiIGQ9Im0wLDBoNzUwdjUwMGgtNzUweiIvPg0KPHBhdGggZmlsbD0iI2ZmYzQwMCIgZD0ibTAsMTI1aDc1MHYyNTBoLTc1MHoiLz4NCjwvc3ZnPg0K">
  </a>
  <a href="https://github.com/alexminator/SML/blob/master/README.md">
    <img height="20px" src="https://img.shields.io/badge/EN-flag.svg?color=555555&style=flat-square&logo=data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgNjAgMzAiIGhlaWdodD0iNjAwIj4NCjxkZWZzPg0KPGNsaXBQYXRoIGlkPSJ0Ij4NCjxwYXRoIGQ9Im0zMCwxNWgzMHYxNXp2MTVoLTMwemgtMzB2LTE1enYtMTVoMzB6Ii8+DQo8L2NsaXBQYXRoPg0KPC9kZWZzPg0KPHBhdGggZmlsbD0iIzAwMjQ3ZCIgZD0ibTAsMHYzMGg2MHYtMzB6Ii8+DQo8cGF0aCBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iNiIgZD0ibTAsMGw2MCwzMG0wLTMwbC02MCwzMCIvPg0KPHBhdGggc3Ryb2tlPSIjY2YxNDJiIiBzdHJva2Utd2lkdGg9IjQiIGQ9Im0wLDBsNjAsMzBtMC0zMGwtNjAsMzAiIGNsaXAtcGF0aD0idXJsKCN0KSIvPg0KPHBhdGggc3Ryb2tlPSIjZmZmIiBzdHJva2Utd2lkdGg9IjEwIiBkPSJtMzAsMHYzMG0tMzAtMTVoNjAiLz4NCjxwYXRoIHN0cm9rZT0iI2NmMTQyYiIgc3Ryb2tlLXdpZHRoPSI2IiBkPSJtMzAsMHYzMG0tMzAtMTVoNjAiLz4NCjwvc3ZnPg0K">
  </a>
</h4>

<a name="readme-top"></a>

<h1 align="center">
  
[![GitHub repo size](https://img.shields.io/github/repo-size/alexminator/SML?logo=github&style=plastic)](https://github.com/alexminator/SML/)
[![GitHub License](https://img.shields.io/github/license/alexminator/SML.svg?logo=github&style=plastic&colorB=68B7EB)](https://github.com/alexminator/SML/blob/master/LICENSE)
[![GitHub stars](https://img.shields.io/github/stars/alexminator/SML.svg?style=plastic&logo=github&color=yellow)](https://github.com/alexminator/SML/stargazers) 
[![GitHub forks](https://img.shields.io/github/forks/alexminator/SML.svg?logo=github&color=teal&style=plastic)](https://github.com/alexminator/SML/network/members)
[![GitHub top language](https://img.shields.io/github/languages/top/alexminator/SML?logo=github&style=plastic&color=blueviolet)](https://github.com/alexminator/SML/)
[![GitHub contributors](https://img.shields.io/github/contributors/alexminator/SML?logo=github&style=plastic)](https://github.com/alexminator/SML/)
[![Watchers](https://img.shields.io/github/watchers/alexminator/SML?logo=github&color=teal&style=plastic)](https://github.com/alexminator/SML/watchers)  
</h1> 

<h4 align="center">:star: Dame una estrella — me motivará a seguir mejorándolo!</h4>

<!-- TABLE OF CONTENTS -->
<details>
  <summary>Tabla de Contenido</summary>
  <ol>
    <li>
      <a href="#sobre-el-proyecto">Sobre el proyecto</a>
      <ul>
        <li><a href="#metas">Metas</a></li>
      </ul>
    </li>
    <li>
      <a href="#comencemos">Comencemos</a>
      <ul>
        <li><a href="#componentes">Componentes</a></li>
        <li><a href="#instalación">Instalación</a></li>
        <li><a href="#diagrama">Diagrama</a></li>
        <li><a href="#código">Código</a></li>
      </ul>
    </li>
    <li><a href="#por-hacer">Por hacer</a></li>
    <li><a href="#colaboradores">Colaboradores</a></li>
    <li><a href="#licencia">Licencia</a></li>
    <li><a href="#contacto">Contacto</a></li>
    <li><a href="#programas">Programas</a></li>
    <li><a href="#agradecimientos">Agradecimientos</a></li>
  </ol>
</details>

<!-- ABOUT THE PROJECT -->
## Sobre el proyecto 

${\color{#ff0000}S}{\color{#ff6e00}M}{\color{#ffdd00}L}$ *(**Smart Music Lamp**)* es un proyecto que surgió con la idea de crear una lámpara controlada por wifi y termino convirtiéndose en mucho más que eso. Se inició con la intención de hacer una versión personal de un sonoff y se decidió usar el esp32, cuya potencia era más que suficiente para la tarea.
Pensándolo mejor, era una pena desperdiciar tanta potencia en una simple tarea de encender y apagar una lámpara.

¿Entonces qué debía agregar para explotar realmente el esp32 y me quedara un producto más completo y funcional?

Al ver a mi mujer cocinando y oyendo música desde el móvil, el cual dejaba en cualquier lado, me vino la idea de dotar a la lámpara de un sistema de audio *(speaker bluetooth)*. Le dije, no sería genial cocinar oyendo música sin tener que dejar el móvil regado en cualquier parte. Podrás controlar el encendido de la lámpara y a la vez pasar la música desde el móvil vía bluetooth a la lámpara y tener música en la cocina.

Si ya tengo una lámpara que reproduce música, ¿por qué no hacerla más alegre y dotarla de colores?

Para ello, agregué una tira de **neopixels** que también son controlados vía web desde el móvil, dando la posibilidad de efectos de luces incluyendo efectos al compás de la música que reproduce la lámpara.
No contento aun, agregué un sensor de temperatura y humedad para tener esos datos reflejados en la web embebida en el esp32.

Como vivo en un país que los cortes de energía son muy comunes y tenía la posibilidad de reproducir música en la lámpara, ¿por qué no aprovecharlo?

Implementé un sistema de alimentación dual *(fuente y batería)* que permite seguir controlando la lámpara vía web y escuchar música luego de un corte de energía. Como es lógico, no podría usar los **neopixels** ya que consumen mucho.

### Metas  

- **_Control de encendido de la lámpara desde el móvil._**
- **_Reproducción de música en la lámpara vía bluetooth desde el móvil._**
- **_Control de la tira neopixel para los diferentes efectos de luces._**
- **_Monitoreo de la carga y el uso de la batería._**
- **_Monitoreo de la temperatura y humedad._**
- **_Control vía web de los botones físicos del altavoz bluetooth._**
- **_Implementación de una web embebida para el control en tiempo real desde el móvil._**

<a href="#readme-top"><img align="right" border="0" src="https://github.com/alexminator/SML/blob/master/img/up_arrow.png" width="22" ></a>

---

<!-- GETTING STARTED -->
## Comencemos 

[![Arduino](https://img.shields.io/badge/ESP32-Project-teal.svg?colorA=teal&colorB=red&style=for-the-badge)](https://github.com/alexminator/SML/)

Poner aqui un video del sml en accion

### Componentes

Para este proyecto se eligió el esp32 por su potencia, cantidad de entradas analógicas y conexión Wifi.
El mismo tendrá una alimentación dual, empleándose una fuente de 5v y una batería de 3.7 v. Un cargador con protección será el encargado de cargar la batería y un convertidor DC-DC step up de elevar el voltaje de la misma a 5V para alimentar el esp32 y el resto de los módulos menos la tira de neopixels que se alimentará siempre de la fuente.

Un módulo relé dual será el encargado de controlar el encendido de la lampará led y del módulo bluetooth. Un sensor DHT22 para la medición de la temperatura y humedad. Un grupo de piezas para la implementación de pequeños circuitos de apoyo.

Para la reproducción de música utilice uno de esos altavoces bluetooth portátiles muy comunes que se pueden encontrar muy baratos como los de la siguiente imagen

![BTspeaker](https://github.com/alexminator/SML/blob/master/img/speakerBT.jpg?raw=true)

Los componentes necesarios son:

1. **Esp32, cualquier variante**

![esp32](https://github.com/alexminator/SML/blob/master/img/esp32.png?raw=true)

2. **Módulo de cargador de batería, TP4056 5V 1A con protección**

![tp4056](https://github.com/alexminator/SML/blob/master/img/tp4056.png?raw=true)

3. **Mini módulo elevador/impulsor DC-DC MT3608**

![mt3608](https://github.com/alexminator/SML/blob/master/img/stepUP.png?raw=true)

4. **Fuente de 5v**
5. **Módulo rele dual**

![relay](https://github.com/alexminator/SML/blob/master/img/relay.png?raw=true)

6. **Tira led neopixel WS2812B 24 leds**

![neopixel](https://github.com/alexminator/SML/blob/master/img/neopixel.png?raw=true)

> **Nota** :
La cantidad de leds a usar dependerá del tamaño de la lámpara y la potencia de la fuente. Se puede cambiar el valor en el código.

7. **Bateria LiPo 3.7v o 18650 3.7v Li-Ion**

![LiPo](https://github.com/alexminator/SML/blob/master/img/Lipo.png?raw=true)
![18650](https://github.com/alexminator/SML/blob/master/img/18650.png?raw=true)

8. **Sensor de temperatura y humedad [DHT22](https://www.sparkfun.com/datasheets/Sensors/Temperature/DHT22.pdf)**

![DHT22](https://github.com/alexminator/SML/blob/master/img/DHT22.png?raw=true)

10. **Resistencias:**
   * 5 x 1K
   * 3 x 10K
   * 2 x 4.7K
   * 1 x 220 ohm           

11. **Condensadores:** 
   * 2 x 0.1 uF
   * 1 x 1 uF /10v

12. **Diodos:**
   * 2 x 1N4148
   * 1 x 1N581x schottky   

13. **Transistores Mosfets**
   * 1 x Mosfet Canal P
   * 3 x Mosfet Canal N

14. **Placa control de altavoz Bluetooth con su Bocina**

15. **Lámpara led que queremos transformar**

> **Nota** :
Para este proyecto use una lampara led circular por considerarlo más estético y elegante. Ustedes podrán hacerlo con cualquier lampara que se acomode a sus necesidades y gusto.

<a href="#readme-top"><img align="right" border="0" src="https://github.com/alexminator/SML/blob/master/img/up_arrow.png" width="22" ></a>

---

### Instalación 

A continuación se muestra una tabla con los pines del esp32 que se conectarán y su denominación.

| ESP32 PINS   | NOMBRE            | FUNCION                      |
| ------------ | -----------       | ------------                 | 
|  4-  `D4`    | `STRIP_PIN`       | Control tira led             | 
|  5-  `D5`    | `VOLUMENUP_PIN`   | Botón V+/FF Bluetooth        |
|  18- `D18`   | `SWITCH_PIN`      | Control encendido Bluetooth  |
|  19- `D19`   | `VOLUMENDOWN_PIN` | Botón V-/REW Bluetooth       |
|  21- `D21`   | `PLAY_PIN`        | Botón Play/Pause Bluetooth   |
|  23- `D23`   | `DHTPIN`          | Control sensor DHT           |
|  32- `D32`   | `LAMP_PIN`        | Control encendido de Lámpara |
|  33- `D33`   | `ADC_PIN`         | Monitor de Batería           |
|  34- `D34`   | `CHARGE_PIN`      | Señal de Batería cargando    |
|  35- `D35`   | `FULL_CHARGE_PIN` | Señal de Batería cargada     |
|  36- `VP`    | `AUDIO_IN_PIN`    | Entrada de audio             |

> **Nota** :
Como se esta usando la conexion Wifi del esp32 no podremos usar ningun pin perteneciente al ADC2 para lecturas analógicas.

### Diagrama

El siguiente esquema ilustra las conexiones para la alimentacion del proyecto.

![smlpower](https://github.com/alexminator/SML/blob/master/img/SML_power.png?raw=true)

> **Nota** : 
El voltaje de salida de la fuente de la lámpara que alimenta los leds blancos de alto brillo no es el reflejado en el esquema, es mucho mas alto. No es importante saberlo para este proyecto.

> ### :point_right: Puede encontrar el esquema [aquí](https://github.com/alexminator/SML/blob/master/img/SML_power.fzz). :star:

Para un mejor entendimiento de la alimentación dual **(load sharing)** que se uso, les adjunto el siguiente esquema.

![loadsharing](https://github.com/alexminator/SML/blob/master/img/load-sharing.png?raw=true)

Cuando se aplica alimentación de la fuente de 5v, este circuito apagará el Mosfet y detendrá el flujo de corriente desde la batería a la carga (Módulo DC-DC), desconectando efectivamente la batería. Siempre que el ${\color{#ffdd00}voltaje\space de\space entrada\space menos\space la\space caída\space en\space el\space diodo\space schottky}$ esté por encima del ${\color{#ffdd00}voltaje\space de\space la\space batería\space menos\space la\space caída\space de\space voltaje\space entre\space drenaje\space y\space fuente}$, la carga utilizará energía de la fuente de 5v a través del diodo schottky.  Esto permite que la batería se cargue normalmente sin perturbaciones externas.

El MOSFET que elija debe tener un RDS (on) lo más bajo posible para minimizar la pérdida de energía, debe poder manejar la corriente que su circuito va a consumir de la batería y tiene un VGS (th) entre 0 V y -2,4 V.

El diodo es para evitar que la corriente fluya desde la batería hacia la fuente de alimentación de 5v.  Debe ser un diodo Schottky que pueda manejar el consumo máximo de corriente de las cargas. **La resistencia RG(10K)** debe asegurarse de que el Mosfet se encienda y conecte la batería a la carga cuando se retire la fuente de alimentación de 5v.

El módulo DC-DC boost converter deberá ajustarse para que su voltaje de salida sea de 5v ya sea con entrada de fuente o batería.

Para monitorear el voltaje de la batería colocaremos un divisor resistivo a la salida del módulo cargador TP4056 y su salida al pin D33 del esp32. 

![battmon](https://github.com/alexminator/SML/blob/master/img/battmon.png?raw=true)

Con la fabulosa librería de [danilopinotti/Battery18650Stats](https://github.com/danilopinotti/Battery18650Stats) se lee el voltaje de la batería y se expresa en porciento. Como las baterías, cuando son de uso su voltaje máximo no es siempre el ideal de 4.2v, la librería de **danilopinotti** no me daba valores prácticos. Me di a la tarea de modificar la librería para incluir en sus parámetros los valores máximo y mínimo de voltaje para hacer más exacto los valores en porciento.

El módulo TP4056 posee 2 leds señalizadores, uno para indicar que está cargando ${\color{#ff0000}(rojo)}$ y otro para indicar que la batería está completamente cargada ${\color{#0022ff}(azul)}$. Analizando el diagrama del módulo se puede notar que dichos leds van a los pines 6 **(standby)** y 7 **(charge)** del IC TP4056. Para activar los leds la salida de dichos pines debe mostrar unos cero lógicos, el cual vamos a detectar en nuestro esp32 y así sabremos el estado del cargador. Para lograr detectar un cero implementaremos el siguiente circuito.

![zero](https://github.com/alexminator/SML/blob/master/img/zero-detect.png?raw=true)

Como se aprecia en el diagrama si los pines 6 o 7 dan una salida mayor de 0v los leds estarán apagados y el diodo (D17) no conducirá por lo que los 3.3v estarían llegando a la entrada del esp32. Si se cumple que el módulo está cargando o la batería se cargó habrá un 0 lógico en dichos pines. Encenderá el led correspondiente y el diodo (D17) conducirá reflejando un nivel bajo en el pin del esp32. En el código estaría representado por las variables ${\color{#ffdd00}isCharging}$ **(está cargando)** y ${\color{#ffdd00}fullyCharge}$ **(batería completamente cargada).**

Durante las pruebas que hice me enfrenté a otro reto, al activar el bluetooth del altavoz el volumen siempre estará a la mitad. Esto parece ser el comportamiento normal de estos altavoces bluetooth, por lo que si queremos controlar el volumen tendremos que usar los botones físicos que trae. Pero como la lámpara estará en un lugar inaccesible no podremos. Y aunque subamos el volumen de nuestro móvil al máximo puede que no logremos el nivel deseado. ¿Entonces cómo podemos controlar remotamente botones físicos?

Analizando el esquema de algunos altavoces bluetooh más comunes del mercado **(chinos)**, note que los botones hacen conmutación de tierra (GND) a un pin del IC. Esto nos facilita la tarea de emular un botón usando el esp32.
En el siguiente esquema se aprecia la solución empleada.

![bt](https://github.com/alexminator/SML/blob/master/img/BT_conn.png?raw=true)

La solución básicamente consiste en usar mosfets como conmutadores simples, al activarse pondrán a tierra el pin del IC del bluetooh. En este modelo de altavoz bluetooh cada botón tiene doble función en dependencia de la duración de la pulsación, esto también será emulado por código. Nos bastara solamente controlar 3 botones **Volumen+(FF)**, **Volumen-(REW)** y **Play(Pause)**. Desde el código controlando la duración del pulso al gate del mosfet simularemos el tiempo de pulsación del botón.
En el esquema además apreciamos como tomar la muestra de audio desde la salida de audio del módulo. Para ellos se implementa un circuito divisor de voltaje y la muestra pasa por una resistencia y un condensador electrolítico hasta el pin **D36(VP)**.

Como se vio en el esquema anterior de las conexiones de alimentación, encender y apagar el bluetooh es a través de un relé **(IN2)** que está controlado por el esp32 desde el **pin D18**.

Por último, quedaría la conexión del sensor de temperatura y humedad DHT22 el cual se hará desde el pin **D23**. Este sensor puede ser alimentado con 5 o 3v así que no tendremos problemas en elegir. Para un mejor monitoreo de la temperatura y humedad se recomienda que el sensor este en contacto con el exterior así que deberán exponerlo.
A continuación algunas fotos de la lámpara ya terminada:

![lamp](https://github.com/alexminator/SML/blob/master/img/lamp.png?raw=true)
![indicator](https://github.com/alexminator/SML/blob/master/img/indicator.png?raw=true)
![inside](https://github.com/alexminator/SML/blob/master/img/inside.png?raw=true)

<a href="#readme-top"><img align="right" border="0" src="https://github.com/alexminator/SML/blob/master/img/up_arrow.png" width="22" ></a>

---

## Código

El proyecto básicamente se resume a controlar la lámpara vía web desde cualquier dispositivo que se conecte a ella. El esp32 se mantiene en modo estación en espera de que otro dispositivo entre en modo AP (punto de acceso portátil) con las credenciales correctas para conectarse a él. ¿Por qué elegí el modo estación?

En la web notaran en la parte inferior derecha los niveles de señales Wifi a los cuales se conecta nuestro dispositivo con la lámpara. Esto solo puede ser logrado si el esp32 está en modo estación. 
El esp32 crea un servidor asíncrono (**[ESPAsyncWebServer](https://github.com/me-no-dev/ESPAsyncWebServer.git)**), es decir, que es capaz de atender a varios clientes de forma simultánea **(8)** y envía datos en formato json mediante websocket. Con esta configuración se logra atender a 8 dispositivos que estén conectados a la lámpara en tiempo real y los cambios se verán reflejados en todos a la vez.

El esp32 contara con una web embebida en la memoria **SPIFFS**, el contenido de dicha web se encuentra en la carpeta ${\color{#ffdd00}data}$ del proyecto. El código está fuertemente comentado así que les hare un resumen del mismo.

Son creados 3 objetos:
  * `StripLed` Control de la tira neopixel
  * `Led` Control del led onboard del esp32
  * `Battery` Control y monitoreo de la batería

El resto de las librerías son para el manejo de los efectos de luces y efectos al compás de la música **(VU)**. Además de las librerías para la creación de un servidor web, monitoreo de la batería y manejo del sensor DHT22. A continuación les muestro las variables más importantes que pudieran variar para acomodarlo a sus necesidades.
1. Variables de depuración
  * `#define DEBUGLEVEL` establecer en **DEBUGLEVEL_DEBUGGING** si desea depurar por consola
  * `#define DHT` comentar con **(//)** sino desea mostrar mensajes referido al sensor DHT22
  * `#define BATTERY` comentar con **(//)** sino desea mostrar mensajes referido al monitoreo de la batería

> **Nota** :
Existen mensajes de depuración obligatorios como los de conexión y servicios web.  

2. Variables de la tira neopixels
  * `#define N_PIXELS` establecer la cantidad de leds que tiene la tira usada.
  * `int brightness` establecer el brillo inicial, por defecto 130 un poco más de la mitad del brillo

3. Variables del manejo de la batería
  * `#define MAXV`  Máximo voltaje con la batería completamente cargada.
  * `#define MINV`  Mínimo voltaje a considerar para comenzar a cargar, por defecto 3.2v

 > **Nota** :
 Para mayor exactitud en estos valores cargue la batería usando el módulo de carga TP4056. Cuando el led de carga completa encienda mida el valor de la batería y tómelo como valor máximo. Para el caso del valor mínimo el módulo DC-DC step up trae en sus especificaciones que para lograr una salida de 5v a la entrada debe de haber un mínimo de 2v. Pero por seguridad se recomienda 3.2v

4. Variables web
  * `const unsigned long refresh` tiempo de demora para el envío de información, 3 segundos por defecto

